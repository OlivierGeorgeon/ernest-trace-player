<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Abstract-Lite User Guide</title>
	<link rel="icon" href="images/favicon.ico" type="image/ico"/>	
	<style>
		.screenshot { border: 2px solid #CCCCCC; }
		.code-sample { margin: 5px 0px; position: relative; display: table; border: 1px solid #CCCCCC; background-color: #EEEEEE; padding: 0 13px;}
		h5 { margin-left: 3em; }
		h4 { margin-left: 1em; }
		h3 { margin-left: 0em; }
		h2 { margin-left: 0em; }
		h1 { margin-left: 0em; }
		body { margin-left: 2em;text-indent: 0em }
		p { vertical-align: middle; }
		p * { vertical-align: middle; }
		pre { text-indent: 2 }
		
		#TOC *
		{
			padding-left: 1em;
			text-decoration: none;
			color: #5555BB;
		}
		
		#TOC ul
		{
			list-style-type: none;
			padding-left: 1em;
		}
		
		#TOC > ul
		{
			padding-left: 0;
		}
	</style>
	
	<script type="text/javascript" src="scripts/auto-toc.js"></script>
	
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	 
	<link href="styles/shCore.css" rel="stylesheet" type="text/css" />
	<link href="styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript">
		SyntaxHighlighter.all()
	</script>
</head>
<body>
	
	<h2>Abstract-Lite User Guide</h2>
	<div class="code-sample" style="color: gray;padding: 2px;">Table of contents<br/><div id="TOC"></div></div>
	
	<p>Abstract-Lite offers an interactive interface to visualize your agents' activity traces.
	Abstract-Lite is a simpler version of <a href="http://liris.cnrs.fr/abstract">ABSTRACT</a> that does not use ontologies nor SPARQL queries.
	Abstract-Lite rather relies on XPATH instructions and XSL stylesheets to help you customize your visualizations.
	Abstract-Lite can display the traces generated by your agents in real time.</p>
	
	<p>Section 1 (Overview) introduces Abstract-Lite's general features.
	Section 2 (Customize the trace visualization) explains how to interactively customize the visualization through the customization panels.
	Section 2 assumes that you have basic knowledge of XPATH. 
	Section 3 (Customization with XSL Stylesheets) introduces the usage of stylesheets for a more advanced customization. 
	Section 3 assumes that you have basic knowledge of XML and XSL. 
	Section 4 (Generate the trace in real time) explains how to implement the tracing functions in a Java agent. 
	
	
	<h3>1. Overview</h3>
	
		<p>Abstract-Lite has a client/server architecture. You can either install your own Abstract-Lite server by following the <a href="install.html">installation procedure</a>, 
		or use our <a href="http://vm.liris.cnrs.fr:34080/abstract/lite/">Abstract-Lite Server</a> hosted by the <a href="http://liris.cnrs.fr">Liris Lab</a>.  
		The client side has been successfully tested with recent versions of Firefox and Chrome, but does not yet support other browsers.</p>

    	<p>Open the Abstract-Lite <a href="index.php">home page</a> with Firefox or Chrome.
		<p>Click <i>Register</i> to create a new user.</p>
		<p>Log in with the user you have created.</p>
		<p>You obtain the page in Figure 1.</p>
		
		<p style="text-align: center;">
		<img class="screenshot" src="images/screen1.png" width="845" /><br/>
		<i>Figure 1: Abstract-Lite client interface</i>
		</p>

		<p><FONT SIZE="+2">➀</font> The <i>Menu Panel</i> (top of the page) provides administrative commands.</p>
		<p><FONT SIZE="+2">➁</font> The <i>Trace List Panel</i> (right side of the page) lets you select a trace from the list. 
		The trace list is initialized with a demo trace when your account is created. 
		The trace list is then populated when you upload new traces or when your agent generates new traces via streaming. 
		Check the <i>Always play last checkbox</i> to automatically display the last trace in the list.
			
		<p><FONT SIZE="+2">➂</font> The <i>Customization Panel</i> (central column) lets you manage your different <i>customizations</i>
		that specify how your traces are visualized.
		A customization is a set of <i>visualization rules</i>.
		In this panel, the <i>Save customization as</i> form lets you name your customizations and save them. 
		The <i>Customization List</i> (empty here) lets you reload a customization.</p>	
		
		<p><FONT SIZE="+2">4</font> The <i>Visualization Rules Panel</i> (column on the left) lets you define your visualization rules. 
		A visualization rule is a rule that defines a graphical symbol to represent an aspect of an event.
		In this panel, the <i>Instantaneous Symbol form</i> and the <i>Interval Symbol form</i> let you create new visualization rules as explained in Section 2.</p> 

	<h3>2. Customize the trace visualization</h3>
	
		<p>Click on the demo trace in the trace list (panel ➁). This makes the player appear as shown in Figure 2.</p>
		
		
		<p style="text-align: center;">
			<img class="screenshot" src="images/screen2.png" width="840.7" /><br />
			<i>Figure 2: The trace player</i>
		</p>
		
		<p>Click the <i>Play</i> button to start playing the trace.</p> 
		<p>Click the <i>Pause</i> button to stop playing the trace. 
		<p>Click the <i>plus</i> and <i>minus</i> buttons to zoom in and out over the horizontal axis, 
		<p>Click the <i>P</i> button to open a printable copy of the trace in a new window. Use your browser's print function to print the trace from this new window.</p>
		
		<p>You can drag the trace to the left or to the right with your mouse by clicking/dragging within the player area.</p> 
		<p>You can click on a symbol to display the data attached to the event related to this symbol. 
		The attached data will appear in a new box just below the player. This box is called the <i>Event Data box</i>.</p>
			
		<h4>Principle of visualization rules</h4>
		
			<p>You define the visualization rules through the <i>Instantaneous Symbol form</i> or the <i>Interval Symbol form</i> in the visualization rule panel. 
			Each of the input fields in these forms takes an XPATH expression. 
			Abstract-Lite interprets the XPATH expressions in the context of each event in the trace. 
			Each event contains an XML tree that you can freely define when generating the trace. 
			Please have a look at the XML structure of our demo trace by downloading the demo trace 
			(using the downward arrow next to the identifier of the trace in the trace list).</p>
			
			<p>Abstract-Lite applies the visualization rules to each event and interprets the result to generate graphical symbols in the player. 
			The field <i>Condition</i> determines whether the symbol is drawn or not.</p>
			
		<h4>Manipulate the list of visualization rules</h4>

			<p>On creation, your account was populated with a set of four demo visualization rules shown in Figure 3.</p>
			
			<p style="text-align: center;">
				<img class="screenshot" src="images/screen11.png" /><br />
				<i>Figure 3: Visualization rules</i>
			</p>

			<p>Click on ⎘ (next to the rule identifier) to copy the fields of a specific rule to the symbol form. 
			This feature is used to copy a rule. 
			To modify a rule, just copy it, modify it, save the new version, and delete the previous version from the list.</p>
			<p>Click on ✗ to delete a rule.</p>
			<p>A new rule is saved and added to the list when you click on the <i>Send</i> button in the symbol form.</p>
			
				
		<h4>Example of instantaneous symbols</h4>
		
			<p>In our demo trace, the events contain a field named <i>primitive_enacted_schema</i>.
			This field indicates the action that the agent has just done ('^': turn left, 'v': turn right, '>': move forward). 
			The first demo rule is responsible for drawing a green triangle pointing upward for each <i>turn left</i> event: </p>
			
			<p style="text-align: center;">
				<img class="screenshot" src="images/screen4.png" /><br />
				<i>Figure 4: Creation of the visualization rule  of turn left events.</i>
			</p>
			
			<p>This rule specifies that the symbol 'up' (a triangle pointing up) should be drawn for each event whose <i>primitive_enacted_schema</i> field is equal to the string '^'.
			This symbol should be drawn in green ('00EE00') and located 10 pixels above the centre of the player area.

			<p>Similarly, the visualization rule in Figure 5 displays a green triangle pointing downward for each <i>turn right</i> event:</p>

			<p style="text-align: center;">
				<img class="screenshot" src="images/screen6.png" /><br/>
				<i>Figure 5: Creation of the visualization rule  of turn right events.</i>
			</p>

			<p>The visualization rule in Figure 6 displays a blue triangle pointing frontward for each <i>move forward</i> event:</p>

			<p style="text-align: center;">
				<img class="screenshot" src="images/screen7.png" /><br />
				<i>Figure 6: Creation of the visualization rule  of move forward events.</i>
			</p>
			
			<p>Note that despite the term <i>instantaneous</i>, instantaneous symbols have a width that can be used to represent the event's duration 
			(provided that the event's duration was recorded in your trace). 
			To do so, customize the <i>X scale</i> field with an expression that evaluates as the event's duration using the information available in your trace.</p> 
			
		<h4>Example of interval symbols</h4>
		
			<p>An interval symbol is a symbol (a line) that represents the interval from a begin event to an end event.</p>
		
			<p>The <i>Interval Symbol form</i> works similarly as the <i>Instantaneous Symbol form</i>. 
			For example, the fourth rule draws the lines that represent the interval during which the property 'current_observation/color' remains unchanged. 
			These lines are positioned vertically according to the property 'current_observation/distance':</p>
		
			<p style="text-align: center;">
				<img class="screenshot" src="images/screen9.png" /><br />
				<i>Figure 7: Creation of the visualization rule of a duration symbol.</i>
			</p>
		
			<p>In the field <i>End condition</i> of this example, the variable <i>$last</i> represents the previous event in the trace.</p>
		
			<p>To facilitate the specification of the visualization rules, we have defined the additional function my:ifthenelse.</p>
		
				<pre class="code-sample">my:ifthenelse(&lt;condition&gt;, &lt;value if true&gt;, &lt;value if false&gt;)</pre>
				<p>If the first parameter is true, this function returns the value of the second parameter. If the first parameter is false, this function returns the value of the third parameter.</p>
				
				<p>Note that you can specify that an interval symbol will change its appearance depending on its ending condition.
				This is useful when the trace is displayed in real time.
				For example, an interval symbol can be displayed in a blue color as long as it is not yet ended, 
				and turn red or green depending on how it ends.</p>
			
				<p>You can now upload your own trace and start customizing its visualization (using "Upload a trace" in panel ➁).</p> 
				
		<h3>3. Customization with XSL Stylesheets</h3>
		
			<p>XSL stylesheets offer a more flexible way of customizing your visualization than the visualization rules presented in Section 2.
			By customizing your XML stylesheets, you have total freedom to specify how your trace is visualized.</p> 
			
			<p>On the Liris server, we, however, had to disable this feature by default because such freedom could open a security flaw. 
			You can either use this feature with your Abstract Server installation, 
			or don't hesitate to contact <a href="mailto: olivier DOT georgeon AT liris DOT cnrs DOT fr">Olivier</a> 
			and <a href="mailto: ronot DOTT py AT gmail DOT com">Pierre-Yves</a> 
			for being granted this feature in your account on the Liris server. 
			</p>
			<p>Once you are granted this feature, you see the <i>Stylesheet panel</i> in Figure 8. 
			The Stylesheet panel lets you modify, download, and upload the stylesheets.</p>
			
			<p style="text-align: center;">
				<img class="screenshot" src="images/screen8.png" /><br/>
				<i>Figure 8: The stylesheet panel.</i>
			</p>
			
			<p>This section introduces the pipeline structure of Abstract-Lite and 
			presents how to create customized XSL stylesheets within this structure.</p>
		
			<h4>The pipeline structure</h4>
			
				<p>Abstract-Lite processes <i>observed elements</i> (named <i>obsels</i>) through a <i>transformation pipeline</i>.
				At the pipeline's input, an obsel is created from each event in the trace.
				The pipeline then processes the obsels through a series of <i>transformation components</i> 
				to progressively construct the SVG code (Scalable Vector Graphics) that specifies how the obsel must be displayed.
				At the pipeline's output, an obsel thus corresponds to a graphical symbol to be drawn in the player.</p>
				
				<p>The pipeline structure is defined in the file <i>pipeline.xml</i>. 
				To prevent loops, transformation components are organized into levels: 
				the levels that appear first in the file apply first.</p> 
				
				<p>Each transformation component has one or several <i>source</i> properties that define the input. 
				There are two special sources: <i>__input__</i> that is the initial source of raw events, 
				and <i>__config__</i> that defines events coming from the user interface. 
				The <i>output</i> element at the end of the pipeline file defines the output of the pipeline.</p>
				
				<p style="text-align: center;font-style:italic;">Table 1: The default file pipeline.xml.</p>
				
			<pre class="brush: xml">&lt;pipeline&gt;
	&lt;default-scale&gt;6.666666&lt;/default-scale&gt;
	&lt;default-center&gt;0&lt;/default-center&gt;
	&lt;graph-width&gt;240&lt;/graph-width&gt;

	&lt;levels&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;select-normalize&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;select-normalize.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;clock&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;clock.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="PHP"&gt;
				&lt;name&gt;buffer-reconfigure&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__config__&lt;/source&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;BufferReconfigureTransformation.inc.php&lt;/file&gt;
				&lt;classname&gt;BufferReconfigureTransformation&lt;/classname&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;tooltip&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;tooltip.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;config-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
					&lt;source&gt;buffer-reconfigure&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;configSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;simple-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;simpleSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

	&lt;/levels&gt;

	&lt;output&gt;
		&lt;source&gt;simple-SVG&lt;/source&gt;
		&lt;source&gt;config-SVG&lt;/source&gt;
		&lt;source&gt;clock&lt;/source&gt;
		&lt;source&gt;tooltip&lt;/source&gt;
	&lt;/output&gt;
&lt;/pipeline&gt;
</pre>

			<h4>The default stylesheets</h4>
				
				<p>The default stylesheets compute the basic information needed by the player (<i>clock.xsl</i>), 
				draw the timestamp ticks (<i>simpleSVG.xsl</i>), 
				call the visualization rules,
				and generate the graphical symbols (<i>BufferReconfigureTransformation.php</i> and <i>configSVG.xsl</i>).</p>
				 
				<p>The stylesheet <i>select-normalise.xsl</i> can be used to filter the incoming events 
				(by default, it doesn't filter anything out).
				The stylesheet <i>simpleSVG.xsl</i> also defines the shapes of the graphical symbols. 
				The stylesheet <i>tooltip.xsl</i> defines the format of the data in the <i>Event Data box</i>.</p>
			
			<h4>The drawing instructions</h4>
			
				<p>The pipeline generates instructions that are passed to the player. 
				The player then executes these instructions to generate the display. 
				There are five instructions: <i>add</i>, <i>delete</i>, <i>clock</i>, <i>tooltip</i>, and <i>save</i>.</p>
				
				<p>The instruction <i>add</i> adds a given symbol (i.e., an SVG element) to the player.</p>
				<p>The instruction <i>delete</i> deletes a symbol from the player.</p>
				<p>The instruction <i>clock</i> shifts the player to a specific timestamp.
				(So far, each new event triggers a <i>clock</i> instruction to synchronise the player. 
				We, however, can imagine some types of events that would not synchronize the player (anticipated events)).</p>
				<p>The instruction <i>tooltip</i> sets the association between a symbol and the event displayed in the <i>Event Data box</i>.</p>
				<p>The <i>save</i> instruction saves some data (a value or a node-set) for use in subsequent processings. 
				Specifically, the save instruction is used to compute interval symbols from multiple events.</p>
				
				<p>The next section illustrates the use of these instructions with examples.</p>
				
			<h4>Examples</h4>
			
				<p>Table 2 shows the demo <i>simpleXML.xsl</i> stylesheet. 
				Notice the <i>include</i> instructions: in particular, <i>shapes.xsl</i> provides shape-drawing facilities in the form of the <i>draw-shape</i> template.</p>
				
				<p style="text-align: center;font-style:italic;">Table 2: The default <i>simpleXML.xsl</i> stylesheet.</p>
				
				<pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:exsl="http://exslt.org/common" xmlns:math="http://exslt.org/math"
	xmlns:dyn="http://exslt.org/dynamic" extension-element-prefixes="exsl math dyn"
	version="1.1"&gt;
	&lt;xsl:param name="state-filename" /&gt;
	&lt;xsl:param name="name" /&gt;
	&lt;xsl:output method="xml" omit-xml-declaration="yes" indent="no" /&gt;
	&lt;xsl:strip-space elements="*" /&gt;

	&lt;xsl:include href="obsel-state.xsl" /&gt;
	&lt;xsl:include href="shapes.xsl" /&gt;

	&lt;!-- Match the obsels from the select-normalizer, that is, the ponctual 
		obsels. --&gt;
	&lt;xsl:template match="obsel" mode="named-saves"&gt;
		&lt;xsl:param name="state" /&gt;

		&lt;!-- We first define some variables which values we will use to draw the 
			shape. --&gt;
		&lt;xsl:variable name="obsel-type"&gt;
			&lt;xsl:choose&gt;
				&lt;xsl:when test="type"&gt;
					 &lt;xsl:value-of select="type" /&gt;
				&lt;/xsl:when&gt;
				&lt;xsl:otherwise&gt;
					&lt;xsl:text&gt;action&lt;/xsl:text&gt;
				&lt;/xsl:otherwise&gt;
			&lt;/xsl:choose&gt;
		&lt;/xsl:variable&gt;
		
		&lt;!-- Lateral position of the shape. --&gt;
		&lt;xsl:variable name="begin-position" select="0" /&gt;
		&lt;xsl:variable name="end-position"
			select="$begin-position + number(@end) - number(@begin)" /&gt;
		
		&lt;xsl:choose&gt;
			&lt;xsl:when test="$obsel-type = 'action'"&gt;
				&lt;add&gt;
					&lt;!-- We create the embedding group. --&gt;
					&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-num-iter"&gt;
							&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
							&lt;xsl:with-param name="end-position" select="$end-position" /&gt;
							&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
	&lt;/xsl:template&gt;
	
	&lt;xsl:template name="draw-num-iter"&gt;
		&lt;xsl:param name="begin-position" /&gt;
		&lt;xsl:param name="end-position" /&gt;
		&lt;xsl:param name="vertical-offset" /&gt;
		
		&lt;xsl:if test="number(@date) mod 10 = 0"&gt;
			&lt;xsl:call-template name="draw-shape"&gt;
				&lt;xsl:with-param name="vert-level" select="$vertical-offset" /&gt;
				&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
				&lt;xsl:with-param name="shape-type" select="'tick-sided-left'" /&gt;
				&lt;xsl:with-param name="text-value" select="clock" /&gt;
				&lt;xsl:with-param name="shape-color" select="'#000000'" /&gt;
				&lt;xsl:with-param name="height" select="'280'" /&gt;
			&lt;/xsl:call-template&gt;
		&lt;/xsl:if&gt;
	&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</pre>

				<p>The input is defined by the template that matches <i>obsel</I> elements. 
				This template applies once for each obsel, and calls sub-templates to actually generate the various symbols. 
				Only one sub-template is called at the moment: the <i>draw-num-iter</i> template. 
				This template is the one that draws the timestamp ticks.</p>
				
				<p>If you look at what this template does in more details, you will notice that the SVG elements 
				(including those returned by the draw-shape template) are embedded into an &lt;add&gt; element. 
				This is how the <i>add</i> instruction works: everything inside an &lt;add&gt; element will be added to the player.</p>
				
				<p>Just inside this <i>add</i> element, you can see a &lt;g&gt; element with several attributes. 
				These attributes specify how the player handles the symbol and places it in the display area. 
				The id element is necessary if you want to reference the symbol later (for example to delete it). 
				The date attribute (timestamp) will determine where the symbol is placed on the x axis. 
				In this example, the obsel-id corresponds to the id of the original event. 
				The id will be used (only) to find the corresponding event when the user clicks on this symbol in order to 
				display the event's data in the Event Data box. 
				(You must be careful to format this data with the corresponding ids; our policy here is to use the original event ids). 
				The stroke attribute is not necessary, just standard SVG.</p>
				
				<p>In the case of interval symbols, the attributes <i>begin</i> and <i>end</i> must be used instead of the attribute <i>date</i>. 
				The player will stretch the interval symbol progressively until it ends 
				(an interval symbol is one-pixel wide before stretching).</p>
				
				<p>Inside this &lt;g&gt; element, we find the template that will generate the effective SVG code to display. 
				To generate this code, the <i>draw-num-iter</i> template calls <i>draw-shape</i>. 
				The parameters taken by the <i>draw-shape</i> template are listed in Table 3.</p>
				
				<p style="text-align: center;font-style:italic;">Table 3: The draw-shape parameters.</p>
				
				<pre class="brush: xml">
					&lt;xsl:template name="draw-shape"&gt;
						&lt;xsl:param name="vert-level" /&gt;
						&lt;xsl:param name="begin-position" /&gt;
						&lt;xsl:param name="shape-type" /&gt;
						&lt;xsl:param name="image-url" select="''" /&gt;
						&lt;xsl:param name="text-value" select="''" /&gt;
						&lt;xsl:param name="shape-color" select="''" /&gt;
						&lt;xsl:param name="height" select="'10'" /&gt;
						&lt;xsl:param name="transform" select="''" /&gt;
						...
					&lt;/xsl:template&gt;</pre>
				<p> These parameters mean:<br/>
					<ul>
						<li><i>vert-level</i> defines the vertical offset (in pixels) at which the symbol must be drawn 
						(0 is the centre, positive values go downward).</li>
						<li><i>begin-position</i> defines the horizontal offset in pixels 
						(0 will center the symbol on the position defined by its timestamp).</li>
						<li><i>shape-type</i> defines what shape should be drawn (square, circle, etc.).</li>
						<li><i>image-url</i> defines the url of the image to draw, when the shape type is 'image'.</li>
						<li><i>text-value</i> defines the text content of the shape if the shape can contain text.</li>
						<li><i>shape-color</i> defines the symbol's filling color.</li>
						<li><i>height</i> defines the symbol's height (in case the shape type uses it).</li>
						<li><i>transform</i> is a string to be used in a SVG transform attribute 
						(for example 'rotate(45) skewX(33)'), that will be applied to the symbol.</li>
					</ul>
				</p>
				
				<p>Now, let us come back to the example of the interval symbol used in Section 2. 
				We want to draw an interval symbol that represents the duration during which 
				the field <i>current_observation/color</i> remains unchanged. 
				For each incoming obsel, we must test if the value of <i>current_observation/color</i> is the same as in the previous obsel. 
				Then, we must expand the previous obsel up to the date of the current obsel. 
				If <i>current_observation/color</i> has changed, we must finish the previous obsel and create a new one.</p>
				
				<p>The first thing is to make our own drawing template and call it from the entry point. 
				The call instruction is shown in Table 4</p>
				
				<p style="text-align: center;font-style:italic;">Table 4: Calling the drawing template.</p>
				
				<pre class="brush: xml">
					&lt;xsl:template match="obsel" mode="named-saves"&gt;
					&lt;xsl:param name="state" /&gt;

						&lt;!-- We first define some variables whose values we will use to draw the 
							shape. --&gt;
						&lt;xsl:variable name="obsel-type"&gt;
							&lt;xsl:choose&gt;
								&lt;xsl:when test="type"&gt;
									 &lt;xsl:value-of select="type" /&gt;
								&lt;/xsl:when&gt;
								&lt;xsl:otherwise&gt;
									&lt;xsl:text&gt;action&lt;/xsl:text&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:variable&gt;
		
						&lt;!-- Lateral position of the shape. --&gt;
						&lt;xsl:variable name="begin-position" select="0" /&gt;
						&lt;xsl:variable name="end-position"
							select="$begin-position + number(@end) - number(@begin)" /&gt;
		
						&lt;xsl:choose&gt;
							&lt;xsl:when test="$obsel-type = 'action'"&gt;
							
								&lt;!-- This, here :. --&gt;
								&lt;xsl:call-template name="draw-example-symbol"&gt;
									&lt;xsl:with-param name="state" select="$state" /&gt;
								&lt;/xsl:call-template&gt;
								&lt;!-- Just up there. --&gt;
								
								&lt;add&gt;
									&lt;!-- We create the embedding group. --&gt;
									&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
										&lt;xsl:call-template name="draw-num-iter"&gt;
											&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
											&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
										&lt;/xsl:call-template&gt;
									&lt;/g&gt;
								&lt;/add&gt;
							&lt;/xsl:when&gt;
							&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:template&gt;</pre>
				
				<p>The drawing template is shown in Table 5.</p>
				
				<p style="text-align: center;font-style:italic;">Table 5: Exemple drawing template of an interval symbol.</p>
				
				
				<pre class="brush: xml">
&lt;xsl:template name="draw-example-symbol"&gt;
		&lt;xsl:param name="state" /&gt;
		&lt;xsl:variable name="sym-state"
			select="$state/save[@name='example-sym']/symbol" /&gt;
		&lt;xsl:variable name="last-state" select="$state/save[@name='example-last']" /&gt;
		&lt;xsl:choose&gt;

			&lt;!-- In the case we have to create a new symbol: at the beginning or
				when colors mismatch between this element and the previous one. --&gt;
			&lt;xsl:when
				test="not($last-state/color) or $last-state/color != current_observation/color"&gt;
				&lt;!-- All we have to do is to add the symbol. --&gt;
				&lt;add&gt;
					&lt;g id="{@id}-s" obsel-id="{@id}" date="{@date}" begin="{@date}"
						end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level"
								select="- current_observation/distance div 5 + 75" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color"
								select="concat('#', current_observation/color)" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

				&lt;!-- We save the symbole caracteristics, we will probably have to draw 
					it again. --&gt;
				&lt;save name='example-sym'&gt;
					&lt;symbol id="{@id}-s" obsel-id="{@id}" begin="{@date}" end="{@date}"
						vert-level="{- current_observation/distance div 5 + 75}" 
						color="#{current_observation/color}" /&gt;
				&lt;/save&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;!-- We want to lengthen the symbole, so we first have to delete
					the old one, before we draw a longer one --&gt;
				&lt;delete obsel-id="{$sym-state/@id}" /&gt;

				&lt;!-- We draw the longer symbol, using the saved properties. --&gt;
				&lt;add&gt;
					&lt;g id="{$sym-state/@id}" obsel-id="{$sym-state/@obsel-id}" date="{$sym-state/@begin}"
						begin="{$sym-state/@begin}" end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level" select="$sym-state/@vert-level" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color" select="$sym-state/@color" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;!-- We save the current obsel color for the next iteration. --&gt;
		&lt;save name='example-last'&gt;
			&lt;color&gt;
				&lt;xsl:value-of select='current_observation/color' /&gt;
			&lt;/color&gt;
		&lt;/save&gt;
	&lt;/xsl:template&gt;
				</pre>
				
		<p>The nodes are saved using the &lt;save&gt; instruction, and retrieved through the state param the next time the template is executed.
		 This allows us to remember the last color value thanks to the <i>example-last</i> save, 
		 and the symbol characteristics thanks to the <i>example-sym</i> save.</p>

	<h3>4. Generate the trace in real time</h3>
	
		<p>This section describes how to implement a java agent that sends traces to Abstract-Lite via streaming. 
		We apologize for the absence of facilities for other programming languages than Java. 
		If you wish to use Abstract-Lite with other kinds of agents, please contact us. 
	
		<p>Click <i>My cookie</i> in panel ➀ to obtain your private <i>cookie value</i> associated with your account. 
		Your agent will use this cookie value to stream its traces to your account in Abstract-Lite.</p>
	
		<p>Download the Abstract-Lite java package by following the <a href="install.html">installation procedure</a>.
		This package provides the java tracer class that your agent can use to send events to Abstract-Lite. 
		This java tracer class is located in the subdir java-tracer/ . 
		A javadoc is available in <a href="java-tracer/tracer-doc/index.html">java-tracer/tracer-doc/index.html</a>.</p>
	
		<p> Your agent must first instantiate the tracer with two parameters. 
		The first parameter is the URL to which the events must be sent.
		The second parameter is the <i>cookie value</i>.  The instantiation instruction looks like this:</p>
		<pre class="code-sample">m_tracer = new XMLStreamTracer("http://vm.liris.cnrs.fr:34080/abstract/lite/php/stream/", "fjSmkmyvAKgByfDAfXuYGjAJLzrWrf");</pre>
		
		<p>Your agent can then generate events using the following methods:</p> 
		
		<p>(a) Generate an event with the <i>newEvent</i> method:</p>
		<pre class="code-sample">m_tracer.newEvent(timestamp);</pre>
		 
		<p>(b) Populate the event with the <i>addEventElement</i> methods:</p>
		<pre class="code-sample">Object element = m_tracer.addEventElement("label", "value");</pre>
		 
		<p>(c) If necessary, add any number of element sub-levels with the <i>addSubelement</i> methods:<p>
		<pre class="code-sample">Object subElement = m_tracer.addSubelement(element, "label", "value");</pre>
		 
		<p>When the event is complete, the agent can finish it with the <i>finishEvent</i> method. Otherwise,  
		an event will be automatically finished when the agent starts the next event:</p>
		<pre class="code-sample">m_tracer.finishEvent();</pre>
		
		<p>We recommend creating only one event for each timestamp, to facilitate the specification of the visualization rules.</p>

	<h3>5. References</h3>
	
	<p>To refer to the ABSTRACT project, please use the following reference:</p>
	
	<p><a href="http://liris.cnrs.fr/abstract/Georgeono2010-abstract.pdf">Supporting Activity Modeling from Activity Traces</a>. Olivier L. Georgeon, Alain Mille, Thierry Bellet, Benoit Mathern, Frank E. Ritter (2011). Expert Systems. doi: 10.1111/j.1468-0394.2011.00584.x.</p> 
	
	<p>To refer to ABSTRACT-LITE and its usage to analyse the activity of artificial agents, please use the following reference:</p>
	
	<p><a href="http://liris.cnrs.fr/ideal/doc/Georgeon2011-ICDL-final.pdf">Early-Stage Vision of Composite Scenes for Spatial Learning and Navigation</a>. In the proceedings of the First Joint IEEE Conference on Development and Learning and on Epigenetic Robotics (ICDL-EPIROB 2011). Olivier L. Georgeon, James B. Marshall, Pierre-Yves R. Ronot. Frankfurt (24-27 August 2011).</p>

	<h3>6. Contact</h3>
	
		<p>Abstract-Lite was developed by Pierre-Yves Ronot at the Liris lab in Lyon (France), as part of the
		<a href="http://liris.cnrs.fr/abstract">ABSTRACT project</a> and of the <a href="http://liris.cnrs.fr/ideal">IDEAL project</a>.</p>
		<p>For any question, comment, feedback, congratulation message, or proposition of collaboration, please contact <a href="mailto: ronot DOTT py AT gmail DOT com">Pierre-Yves Ronot </a> and <a href="mailto: olivier DOT georgeon AT liris DOT cnrs DOT fr">Olivier Georgeon</a>. 

</body>
</html>
