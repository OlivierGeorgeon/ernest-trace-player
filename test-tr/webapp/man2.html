<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Abstract-Lite User Guide Advanced Features</title>
	<link rel="icon" href="images/favicon.ico" type="image/ico"/>	
    <link rel="StyleSheet"  type="text/css"  href="al.css" >
	<style>
		.screenshot { border: 2px solid #CCCCCC; }
		.code-sample { margin: 5px 0px; position: relative; display: table; border: 1px solid #CCCCCC; background-color: #EEEEEE; padding: 0 13px;}
		h5 { margin-left: 3em; }
		h4 { margin-left: 1em; }
		h3 { margin-left: 0em; }
		h2 { margin-left: 0em; }
		h1 { margin-left: 0em; }
		body { margin-left: 2em;text-indent: 0em }
		p { vertical-align: middle; }
		p * { vertical-align: middle; }
		pre { text-indent: 2 }
		
		#TOC *
		{
			padding-left: 1em;
			text-decoration: none;
			color: #5555BB;
		}
		
		#TOC ul
		{
			list-style-type: none;
			padding-left: 1em;
		}
		
		#TOC > ul
		{
			padding-left: 0;
		}
		table.sample {
			margin:0 auto; 
			border-width: 1px;
			border-right:0px;			
			border-spacing: 0px;
			border-style: solid;
			border-color: gray;
			border-collapse: separate;
			background-color: white;
		}
		table.sample th {
			border-width: 0px;
			border-bottom:1px;
			border-right:1px;
			padding: 2px;
			border-style: solid;
			border-color: gray;
			background-color: white;
			-moz-border-radius: ;
			font-weight: bold; 
		}
		table.sample td {
			border-width: 0px;
			border-right:1px;
			padding: 2px;
			border-style: solid;
			border-color: gray;
			background-color: white;
			-moz-border-radius: ;
		}
	</style>
	
	<script type="text/javascript" src="scripts/auto-toc.js"></script>
	
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	 
	<link href="styles/shCore.css" rel="stylesheet" type="text/css" />
	<link href="styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript">
		SyntaxHighlighter.all()
	</script>
</head>
<body>
	
	<h1></h1>
	<div class="pathBar">
		<table width="100%"><tr><td>
			You are here :
			<a href=".">Abstract Lite</a>
			<strong> » </strong>
			<a href="man.html">User Guide</a>
			<strong> » </strong>
			Advanced Features
			</td>
			<td style="text-align: right;">
			</td>
			</tr>
		</table>
	</div>

	<h2>Page 2. Advanced features</h2>
	<div class="code-sample" style="color: gray;padding: 2px;">Table of contents<br/><div id="TOC"></div></div>
	
	<p>Section 3 (Customization with XSL Stylesheets) introduces the usage of XSL stylesheets. It requires background knowledge of XML and XSL. 
	Section 4 (Generate the trace in real time) explains how to implement the tracing functions in a Java agent. 
		
		<h3>3. Customization with XSL Stylesheets</h3>
		
			<p>XSL stylesheets offer a more flexible way of customizing your visualization than the visualization rules presented in Section 2.
			By customizing your XML stylesheets, you have total freedom to specify how your trace is visualized.</p> 
			
			<p>We, however, had to disable this feature by default because such freedom could open a security flaw on the server. 
			You can either use this feature on your own server, 
			or don't hesitate to ask <a href="mailto: olivier DOT georgeon AT liris DOT cnrs DOT fr">Olivier</a> 
			and <a href="mailto: ronot DOTT py AT gmail DOT com">Pierre-Yves</a> 
			for being granted this feature on the Liris server. 
			</p>
			<p>Once you are granted this feature, you see the <i>Stylesheet panel</i> in Figure 8. 
			The Stylesheet panel lets you modify, download, and upload the stylesheets.</p>
			
			<p style="text-align: center;">
				<img class="screenshot" src="images/figure8.png" /><br/>
				<i>Figure 8: The stylesheet panel.</i>
			</p>
			
			<p>This section introduces the pipeline structure of Abstract-Lite and 
			presents how to create customized XSL stylesheets within this structure.</p>
		
			<h4>The pipeline structure</h4>
			
				<p>Abstract-Lite processes <i>observed elements</i> (named <i>obsels</i>) through a <i>transformation pipeline</i>.
				Each event in the trace generates an obsel which enters the pipeline.
				The pipeline processes the obsel through a series of <i>transformation components</i> 
				to progressively construct the SVG code that specifies how the obsel display.
				At the pipeline's output, an obsel thus corresponds to a graphical symbol to be drawn in the player.</p>
				
				<p>The pipeline structure is defined in the file <i>pipeline.xml</i>. 
				To prevent loops, transformation components are organized into levels: 
				the levels that appear first in the file apply first.</p> 
				
				<p>Each transformation component has one or several <i>source</i> properties that define the input. 
				There are two special sources: <i>__input__</i> that is the initial source of raw events, 
				and <i>__config__</i> that defines events coming from the user interface. 
				The <i>output</i> element at the end of the pipeline file defines the output of the pipeline.</p>
				
				<p style="text-align: center;font-style:italic;">Table 2: The default file pipeline.xml.</p>
				
			<pre class="brush: xml">&lt;pipeline&gt;
	&lt;default-scale&gt;6.666666&lt;/default-scale&gt;
	&lt;default-center&gt;0&lt;/default-center&gt;
	&lt;graph-width&gt;240&lt;/graph-width&gt;

	&lt;levels&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;select-normalize&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;select-normalize.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;clock&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;clock.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="PHP"&gt;
				&lt;name&gt;buffer-reconfigure&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__config__&lt;/source&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;BufferReconfigureTransformation.inc.php&lt;/file&gt;
				&lt;classname&gt;BufferReconfigureTransformation&lt;/classname&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;tooltip&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;tooltip.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;config-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
					&lt;source&gt;buffer-reconfigure&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;configSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;simple-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;simpleSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

	&lt;/levels&gt;

	&lt;output&gt;
		&lt;source&gt;simple-SVG&lt;/source&gt;
		&lt;source&gt;config-SVG&lt;/source&gt;
		&lt;source&gt;clock&lt;/source&gt;
		&lt;source&gt;tooltip&lt;/source&gt;
	&lt;/output&gt;
&lt;/pipeline&gt;
</pre>

			<h4>The default stylesheets</h4>
			
				<p>Table 3 summarizes the main stylesheets provided by default. 
				
				<p style="text-align: center;font-style:italic;">Table 3: The main stylesheets provided by default.</p>
				
				<table class="sample">
					<tr>
						<th>Stylesheet</th>
						<th>Description</th>
						<th>Remarks</th>
					</tr>
					<tr>
						<td>pipeline.xml</td>
						<td>The pipeline defines the order in which the stylesheets are processed.</td>
						<td>&lt;graph-width&gt; defines the height of the trace player area.</td>
					</tr>
					<tr>
						<td>clock.xsl</td>
						<td>Compute the basic information needed by the player.</td>
						<td>&nbsp;</td>
					</tr>
					<tr>
						<td>simpleSVG.xsl</td>
						<td>Draw the various tapes in the trace.</td>
						<td>The visual field.</td>
					</tr>
					<tr>
						<td>BufferReconfigureTransformation.php</td>
						<td>Call the visualization rules.</td>
						<td>&nbsp;</td>
					</tr>
					<tr>
						<td>configSVG.xsl</td>
						<td>Generate the graphical symbols.</td>
						<td>&nbsp;</td>
					</tr>
					<tr>
						<td>select-normalise.xsl</td>
						<td>Can be used to filter the incoming events </td>
						<td>By default, it doesn't filter anything out.</td>
					</tr>
					<tr>
						<td>tooltip.xsl</td>
						<td>Define the format of the data in the <i>Event Data box</i>.</td>
						<td>&nbsp;</td>
					</tr>
					<tr>
						<td>shapes.xsl</td>
						<td>Define the shapes of the symbols.</td>
						<td>The time-stamps</td>
					</tr>
				</table>
				
			<h4>The drawing instructions</h4>
			
				<p>The pipeline generates instructions that are passed to the player. 
				The player then executes these instructions to generate the display. 
				There are five instructions: <i>add</i>, <i>delete</i>, <i>clock</i>, <i>tooltip</i>, and <i>save</i>.</p>
				
				<p>The instruction <i>add</i> adds a given symbol (i.e., an SVG element) to the player.</p>
				<p>The instruction <i>delete</i> deletes a symbol from the player.</p>
				<p>The instruction <i>clock</i> shifts the player to a specific timestamp.
				(So far, each new event triggers a <i>clock</i> instruction to synchronise the player. 
				We, however, can imagine some types of events that would not synchronize the player (anticipated events)).</p>
				<p>The instruction <i>tooltip</i> sets the association between a symbol and the event displayed in the <i>Event Data box</i>.</p>
				<p>The <i>save</i> instruction saves some data (a value or a node-set) for use in subsequent processings. 
				Specifically, the save instruction is used to compute interval symbols from multiple events.</p>
				
				<p>The next section illustrates the use of these instructions with examples.</p>
				
			<h4>Examples</h4>
			
				<p>Table 4 shows the demo <i>simpleXML.xsl</i> stylesheet. 
				Notice the <i>include</i> instructions: in particular, <i>shapes.xsl</i> provides shape-drawing facilities in the form of the <i>draw-shape</i> template.</p>
				
				<p style="text-align: center;font-style:italic;">Table 4: The default <i>simpleXML.xsl</i> stylesheet.</p>
				
				<pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:exsl="http://exslt.org/common" xmlns:math="http://exslt.org/math"
	xmlns:dyn="http://exslt.org/dynamic" extension-element-prefixes="exsl math dyn"
	version="1.1"&gt;
	&lt;xsl:param name="state-filename" /&gt;
	&lt;xsl:param name="name" /&gt;
	&lt;xsl:output method="xml" omit-xml-declaration="yes" indent="no" /&gt;
	&lt;xsl:strip-space elements="*" /&gt;

	&lt;xsl:include href="obsel-state.xsl" /&gt;
	&lt;xsl:include href="shapes.xsl" /&gt;

	&lt;!-- Match the obsels from the select-normalizer, that is, the ponctual 
		obsels. --&gt;
	&lt;xsl:template match="obsel" mode="named-saves"&gt;
		&lt;xsl:param name="state" /&gt;

		&lt;!-- We first define some variables which values we will use to draw the 
			shape. --&gt;
		&lt;xsl:variable name="obsel-type"&gt;
			&lt;xsl:choose&gt;
				&lt;xsl:when test="type"&gt;
					 &lt;xsl:value-of select="type" /&gt;
				&lt;/xsl:when&gt;
				&lt;xsl:otherwise&gt;
					&lt;xsl:text&gt;action&lt;/xsl:text&gt;
				&lt;/xsl:otherwise&gt;
			&lt;/xsl:choose&gt;
		&lt;/xsl:variable&gt;
		
		&lt;!-- Lateral position of the shape. --&gt;
		&lt;xsl:variable name="begin-position" select="0" /&gt;
		&lt;xsl:variable name="end-position"
			select="$begin-position + number(@end) - number(@begin)" /&gt;
		
		&lt;xsl:choose&gt;
			&lt;xsl:when test="$obsel-type = 'action'"&gt;
				&lt;add&gt;
					&lt;!-- We create the embedding group. --&gt;
					&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-num-iter"&gt;
							&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
							&lt;xsl:with-param name="end-position" select="$end-position" /&gt;
							&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
	&lt;/xsl:template&gt;
	
	&lt;xsl:template name="draw-num-iter"&gt;
		&lt;xsl:param name="begin-position" /&gt;
		&lt;xsl:param name="end-position" /&gt;
		&lt;xsl:param name="vertical-offset" /&gt;
		
		&lt;xsl:if test="number(@date) mod 10 = 0"&gt;
			&lt;xsl:call-template name="draw-shape"&gt;
				&lt;xsl:with-param name="vert-level" select="$vertical-offset" /&gt;
				&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
				&lt;xsl:with-param name="shape-type" select="'tick-sided-left'" /&gt;
				&lt;xsl:with-param name="text-value" select="clock" /&gt;
				&lt;xsl:with-param name="shape-color" select="'#000000'" /&gt;
				&lt;xsl:with-param name="height" select="'280'" /&gt;
			&lt;/xsl:call-template&gt;
		&lt;/xsl:if&gt;
	&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</pre>

				<p>The input is defined by the template that matches <i>obsel</I> elements. 
				This template applies once for each obsel, and calls sub-templates to actually generate the various symbols. 
				Only one sub-template is called at the moment: the <i>draw-num-iter</i> template. 
				This template is the one that draws the timestamp ticks.</p>
				
				<p>If you look at what this template does in more details, you will notice that the SVG elements 
				(including those returned by the draw-shape template) are embedded into an &lt;add&gt; element. 
				This is how the <i>add</i> instruction works: everything inside an &lt;add&gt; element will be added to the player.</p>
				
				<p>Just inside this <i>add</i> element, you can see a &lt;g&gt; element with several attributes. 
				These attributes specify how the player handles the symbol and places it in the display area. 
				The id element is necessary if you want to reference the symbol later (for example to delete it). 
				The date attribute (timestamp) will determine where the symbol is placed on the x axis. 
				In this example, the obsel-id corresponds to the id of the original event. 
				The id will be used (only) to find the corresponding event when the user clicks on this symbol in order to 
				display the event's data in the Event Data box. 
				(You must be careful to format this data with the corresponding ids; our policy here is to use the original event ids). 
				The stroke attribute is not necessary, just standard SVG.</p>
				
				<p>In the case of interval symbols, the attributes <i>begin</i> and <i>end</i> must be used instead of the attribute <i>date</i>. 
				The player will stretch the interval symbol progressively until it ends 
				(an interval symbol is one-pixel wide before stretching).</p>
				
				<p>Inside this &lt;g&gt; element, we find the template that will generate the effective SVG code to display. 
				To generate this code, the <i>draw-num-iter</i> template calls <i>draw-shape</i>. 
				The parameters taken by the <i>draw-shape</i> template are listed in Table 5.</p>
				
				<p style="text-align: center;font-style:italic;">Table 5: The draw-shape parameters.</p>
				
				<pre class="brush: xml">
					&lt;xsl:template name="draw-shape"&gt;
						&lt;xsl:param name="vert-level" /&gt;
						&lt;xsl:param name="begin-position" /&gt;
						&lt;xsl:param name="shape-type" /&gt;
						&lt;xsl:param name="image-url" select="''" /&gt;
						&lt;xsl:param name="text-value" select="''" /&gt;
						&lt;xsl:param name="shape-color" select="''" /&gt;
						&lt;xsl:param name="height" select="'10'" /&gt;
						&lt;xsl:param name="transform" select="''" /&gt;
						...
					&lt;/xsl:template&gt;</pre>
				<p> These parameters mean:<br/>
					<ul>
						<li><i>vert-level</i> defines the vertical offset (in pixels) at which the symbol must be drawn 
						(0 is the centre, positive values go downward).</li>
						<li><i>begin-position</i> defines the horizontal offset in pixels 
						(0 will center the symbol on the position defined by its timestamp).</li>
						<li><i>shape-type</i> defines what shape should be drawn (square, circle, etc.).</li>
						<li><i>image-url</i> defines the url of the image to draw, when the shape type is 'image'.</li>
						<li><i>text-value</i> defines the text content of the shape if the shape can contain text.</li>
						<li><i>shape-color</i> defines the symbol's filling color.</li>
						<li><i>height</i> defines the symbol's height (in case the shape type uses it).</li>
						<li><i>transform</i> is a string to be used in a SVG transform attribute 
						(for example 'rotate(45) skewX(33)'), that will be applied to the symbol.</li>
					</ul>
				</p>
				
				<p>Now, let us come back to the example of the interval symbol used in Section 2. 
				We want to draw an interval symbol that represents the duration during which 
				the field <i>current_observation/color</i> remains unchanged. 
				For each incoming obsel, we must test if the value of <i>current_observation/color</i> is the same as in the previous obsel. 
				Then, we must expand the previous obsel up to the date of the current obsel. 
				If <i>current_observation/color</i> has changed, we must finish the previous obsel and create a new one.</p>
				
				<p>The first thing is to make our own drawing template and call it from the entry point. 
				The call instruction is shown in Table 6</p>
				
				<p style="text-align: center;font-style:italic;">Table 6: Calling the drawing template.</p>
				
				<pre class="brush: xml">
					&lt;xsl:template match="obsel" mode="named-saves"&gt;
					&lt;xsl:param name="state" /&gt;

						&lt;!-- We first define some variables whose values we will use to draw the 
							shape. --&gt;
						&lt;xsl:variable name="obsel-type"&gt;
							&lt;xsl:choose&gt;
								&lt;xsl:when test="type"&gt;
									 &lt;xsl:value-of select="type" /&gt;
								&lt;/xsl:when&gt;
								&lt;xsl:otherwise&gt;
									&lt;xsl:text&gt;action&lt;/xsl:text&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:variable&gt;
		
						&lt;!-- Lateral position of the shape. --&gt;
						&lt;xsl:variable name="begin-position" select="0" /&gt;
						&lt;xsl:variable name="end-position"
							select="$begin-position + number(@end) - number(@begin)" /&gt;
		
						&lt;xsl:choose&gt;
							&lt;xsl:when test="$obsel-type = 'action'"&gt;
							
								&lt;!-- This, here :. --&gt;
								&lt;xsl:call-template name="draw-example-symbol"&gt;
									&lt;xsl:with-param name="state" select="$state" /&gt;
								&lt;/xsl:call-template&gt;
								&lt;!-- Just up there. --&gt;
								
								&lt;add&gt;
									&lt;!-- We create the embedding group. --&gt;
									&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
										&lt;xsl:call-template name="draw-num-iter"&gt;
											&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
											&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
										&lt;/xsl:call-template&gt;
									&lt;/g&gt;
								&lt;/add&gt;
							&lt;/xsl:when&gt;
							&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:template&gt;</pre>
				
				<p>The drawing template is shown in Table 7.</p>
				
				<p style="text-align: center;font-style:italic;">Table 7: Exemple drawing template of an interval symbol.</p>
				
				
				<pre class="brush: xml">
&lt;xsl:template name="draw-example-symbol"&gt;
		&lt;xsl:param name="state" /&gt;
		&lt;xsl:variable name="sym-state"
			select="$state/save[@name='example-sym']/symbol" /&gt;
		&lt;xsl:variable name="last-state" select="$state/save[@name='example-last']" /&gt;
		&lt;xsl:choose&gt;

			&lt;!-- In the case we have to create a new symbol: at the beginning or
				when colors mismatch between this element and the previous one. --&gt;
			&lt;xsl:when
				test="not($last-state/color) or $last-state/color != current_observation/color"&gt;
				&lt;!-- All we have to do is to add the symbol. --&gt;
				&lt;add&gt;
					&lt;g id="{@id}-s" obsel-id="{@id}" date="{@date}" begin="{@date}"
						end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level"
								select="- current_observation/distance div 5 + 75" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color"
								select="concat('#', current_observation/color)" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

				&lt;!-- We save the symbole caracteristics, we will probably have to draw 
					it again. --&gt;
				&lt;save name='example-sym'&gt;
					&lt;symbol id="{@id}-s" obsel-id="{@id}" begin="{@date}" end="{@date}"
						vert-level="{- current_observation/distance div 5 + 75}" 
						color="#{current_observation/color}" /&gt;
				&lt;/save&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;!-- We want to lengthen the symbole, so we first have to delete
					the old one, before we draw a longer one --&gt;
				&lt;delete obsel-id="{$sym-state/@id}" /&gt;

				&lt;!-- We draw the longer symbol, using the saved properties. --&gt;
				&lt;add&gt;
					&lt;g id="{$sym-state/@id}" obsel-id="{$sym-state/@obsel-id}" date="{$sym-state/@begin}"
						begin="{$sym-state/@begin}" end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level" select="$sym-state/@vert-level" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color" select="$sym-state/@color" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;!-- We save the current obsel color for the next iteration. --&gt;
		&lt;save name='example-last'&gt;
			&lt;color&gt;
				&lt;xsl:value-of select='current_observation/color' /&gt;
			&lt;/color&gt;
		&lt;/save&gt;
	&lt;/xsl:template&gt;
				</pre>
				
		<p>The nodes are saved using the &lt;save&gt; instruction, and retrieved through the state param the next time the template is executed.
		 This allows us to remember the last color value thanks to the <i>example-last</i> save, 
		 and the symbol characteristics thanks to the <i>example-sym</i> save.</p>

	<h3>4. Generate the trace in real time</h3>
	
		<p>This section describes how to implement a java agent that sends traces to Abstract-Lite via http. 
		There is currently no support for other langages than Java. 
	
		<p>Click <i>My cookie</i> in the main menu to obtain your private <i>cookie value</i> associated with your account. 
		Your agent will use this cookie value to stream its traces to your account in Abstract-Lite.</p>
	
		<p>Download the Abstract-Lite java package by following the <a href="install.html">installation procedure</a>.
		This package provides the java tracer class that your agent can use to send events to Abstract-Lite. 
		This java tracer class is located in the subdir <i>java-tracer/</i>. 
		A javadoc is available in <i>java-tracer/tracer-doc/index.html</i> 
		and <a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/index.html">online</a>.</p>
	
		<p> Your agent must first instantiate the tracer of type 
		<a href ="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html">XMLStreamTracer</a>
		with two parameters. 
		The first parameter is the URL to which the events must be sent.
		The second parameter is the <i>cookie value</i>.  The instantiation instruction looks like this:</p>
		<pre class="code-sample">m_tracer = new XMLStreamTracer("http://vm.liris.cnrs.fr:34080/abstract/lite/php/stream/", "fjSmkmyvAKgByfDAfXuYGjAJLzrWrf");</pre>
		
		<p>Your agent can then generate events using the following methods:</p> 
		
		<p>(a) Generate an event with the 
		<a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html#newEvent%28java.lang.String,%20java.lang.String,%20int%29">startNewEvent</a> 
		method:</p>
		<pre class="code-sample">m_tracer.startNewEvent(timestamp);</pre>
		 
		<p>(b) Populate the event with the 
		<a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html#addEventElement%28java.lang.String,%20java.lang.String%29">addEventElement</a>
		method:</p>
		<pre class="code-sample">Object element = m_tracer.addEventElement("label", "textValue");</pre>
		 
		<p>(c) If necessary, add any number of element sub-levels with the 
		<a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html#addSubelement%28org.w3c.dom.Element,%20java.lang.String,%20java.lang.String%29">addSubelement</a> 
		method:<p>
		<pre class="code-sample">Object subElement = m_tracer.addSubelement(element, "label", "textValue");</pre>
		 
		<p>(d) When the event is completed, close it with the 
		<a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html#finishEvent%28%29">finishEvent</a>
		method. Otherwise, an event will be automatically finished when the agent starts the next event:</p>
		<pre class="code-sample">m_tracer.finishEvent();</pre>
		
		<p>The agent can signal the end of the trace with the 
		<a href="http://ernest-trace-player.googlecode.com/svn/test-tr/java-tracer/tracer-doc/tracing/XMLStreamTracer.html#close%28%29">close</a>
		method.</p>
		
		<p>In the Trace list, check the <i>Always play last</i> checkbox for Abstract-Lite to display the latest trace sent by the agent.</p>
		
		<p>We recommend creating only one event for each timestamp, to facilitate the specification of the visualization rules.</p>

	<h3>Back</h3>
	
	<p>Back to <a href="man.html">Page 1</a>.</p>
</body>
</html>
