<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Abstract Lite User Guide</title>
	<style>
		.screenshot { border: 2px solid #CCCCCC; }
		.code-sample { margin: 5px 0px; position: relative; display: table; border: 1px solid #CCCCCC; background-color: #EEEEEE; padding: 0 13px;}
		h5 { margin-left: 3em; }
		h4 { margin-left: 2em; }
		h3 { margin-left: 1em; }
		h2 { margin-left: 0; }
		h1 { margin-left: -1em; }
		body { text-indent: 2em }
		p { vertical-align: middle; }
		p * { vertical-align: middle; }
		
		#TOC *
		{
			padding-left: 1em;
			text-decoration: none;
			color: #5555BB;
		}
		
		#TOC ul
		{
			list-style-type: none;
			padding-left: 1em;
		}
		
		#TOC > ul
		{
			padding-left: 0;
		}
	</style>
	
	<script type="text/javascript" src="scripts/auto-toc.js"></script>
	
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	 
	<link href="styles/shCore.css" rel="stylesheet" type="text/css" />
	<link href="styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript">
		SyntaxHighlighter.all()
	</script>
</head>
<body>
	
	<h2>Abstract Lite User Guide</h2>
	<div class="code-sample" style="color: gray;padding: 2px;">Table of contents<br/><div id="TOC"></div></div>
	
	<p>Abstract Lite offers an interactive interface to visualize your agents' activity traces.
	Abstract Lite is a simpler version of <a href="http://liris.cnrs.fr/abstract">ABSTRACT</a> that does not use ontologies nor SPARQL queries.
	Abstract Lite rather relies only on XPATH instructions and XSL stylesheets to help you customize your visualizations.
	Abstract Lite can display the traces generated by your agents in real time.</p>
	
	<p>Section 1 (Overview) introduces Abstract Lite's general features.
	Section 2 (Customize the trace visualization) explains how to interactively customize the visualization through the customization panels.
	Section 3 (Customization with XSL Stylesheets) introduces the usage of stylesheets for a more advanced configuration of your visualization. 
	Section 3 assumes that you have basic knowledge in XML, XSL, and XPATH. 
	Section 4 (Generate the trace in real time) explains how to implement the tracing functions in a Java agent. 
	
	
	<h3>1. Overview</h3>
	
		<p>Abstract Lite has a client/server architecture. You can either install your own Abstract Lite server by following the <a href="install.html">installation procedure</a>, 
		or use our <a href="http://vm.liris.cnrs.fr:34080/abstract/lite/">Abstract Lite Serveur</a> hosted by the <a href="http://liris.cnrs.fr">Liris Lab</a>.  
		The client side has been successfully tested with recent versions of Firefox and Chrome, but does not yet support other browsers.</p>

    	<p>Open the Abstract Lite home page in Firefox or Chrome (e.g., <a href="http://vm.liris.cnrs.fr:34080/abstract/lite/">Abstract Lite - Liris Server</a>).
		<p>Click <i>Register</i> to create a new user.</p>
		<p>Log in with the user you have created.</p>
		<p>You obtain the page shown in Figure 1: </p>
		<img class="screenshot" src="images/screen1.png" width="845" />

		<p><FONT SIZE="+2">➀</font> The menu panel (top of the page) provides administrative commands.</p>
		<p><FONT SIZE="+2">➁</font> The trace selector panel (right side of the page) lets you select a trace from the list. 
		The list of traces is initialized with a demo trace when your account is created. 
		The list is then populated when you upload new traces or when your agent generates new traces via streaming. 
		Check the <i>Always play last</i> checkbox to automatically display the last trace in the list.
			
		<p><FONT SIZE="+2">➂</font> The customization panels (the gray panels in Figure 1, plus the three panels <i>Share transformation</i>, 
		<i>Save config as</i>, and <i>Existing configs</i>) let you enter customization rules (that define the symbols used to represent the different types of events in the trace),
		and let you manage the coustomization rules (save and load sets of customization rules). 
		The <i>New instantaneous symbol</i> and <i>New interval symbol</i> forms let you create new rules. 
		Just beneath these forms is the list of the current customization rules (not visible in Figure 1). 
		The <i>Save config as</i> form lets you name your set of rules and save it as a set. 
		The <i>saved configurations</i> forms (Existing configs, empty here) lets you reload a set of configuration.</p>	

	<h3>2. Customize the trace visualization</h3>
	
		<p>Click on the demo trace in panel ➁. This makes the player appear as shown in Figure 2 :</p>
		<img class="screenshot" src="images/screen2.png" width="840.7" /><br />
		
		<p>Click the <i>Play</i> button to start playing the trace.</p> 
		<p>Click the <i>Pause</i> button to stop playing the trace. 
		<p>Click the <i>plus</i> and <i>minus</i> buttons to zoom in and out over the horizontal axis, 
		<p>Click the <i>P</i> button to open a printable copy of the trace in a new window. Use your browser's print function to print the trace from this new window.</p>
		
		<p>You can drag the trace to the left or to the right with your mouse within the player area.</p> 
		<p>You can click on a symbol to display the data attached to this symbol. The attached data will appear in a new box just below the player.</p>
			
		<h4>Principle of customization rules</h4>
		
			<p>You define the customization rules through the <i>New instantaneous symbol</i> form and the <i>New interval symbol</i> form in the customization panels ➂. 
			Each of the input fields in these <i>new symbol</i> forms takes an XPATH expression. 
			Abstract Lite interprets the XPATH expressions in the context of each event in the trace. 
			Each event contains an XML tree that you can freely define when generating the trace. 
			Please have a look at the XML structure of our demo trace by downloading the demo trace 
			(using the downward arrow next to the trace identifier in the list of traces, panel ➁).</p>
			
			<p>Abstract Lite applies the customization rules to each event and interprets the result to draw the event as a symbol. 
			The field <i>Condition</i> determines whether the symbol is drawn or not.</p>
			
		<h4>Manipulating the list of customization rules</h4>

			<p>The list of customization rules appears below the new symbol forms. On creation, your account was populated with a set of four demo customization rules:</p>
			<img class="screenshot" src="images/screen11.png" /><br />
			<p>Click on ⎘, next to the rule identifier, to copy the rule's fields to the symbol form. This is used to duplicate a rule. 
			To modify a rule, just copy it, modify it, save the new version, and delete the previous version from the list.</p>
			<p>Click on ✗ to delete a rule.</p>
			<p>A new rule is added to the list when you click an the <i>Send</i> button in the new symbol form.</p>
			
				
		<h4>Example of instantaneous symbols</h4>
		
			<p>In our demo trace, the events contain a field named <i>primitive_enacted_schema</i>.
			This field indicates the action that the agent has just done ('^': turn left, 'v': turn right, '>': move forward). 
			The first demo rule is responsible for drawing a green triangle pointing upward for each <i>turn left</i> event: </p>
			
			<img class="screenshot" src="images/screen4.png" /><br />
			
			<p>This rule specifies that the symbol 'up' (a triangle pointing up) should be drawn for each event whose <i>primitive_enacted_schema</i> field is equal to the string '^'.
			This symbol should be drawn in green ('00EE00') and located 10 pixels above the center of the player area.

			<p>Similarly, the following rule displays a green triangle pointing downward for each <i>turn right</i> event:</p>

			<img class="screenshot" src="images/screen6.png" />

			<p>The following rule displays a blue triangle pointing frontward for each <i>move forward</i> event:</p>

			<img class="screenshot" src="images/screen7.png" /><br />
			
			<p>Note that despite the term <i>instantaneous</i>, instantaneous symbols have a width that can be used to represent the event's duration 
			(provided that the event's duration was recorded in your trace). 
			To do so, customize the <i>X scale</i> field with an expression that evaluates as the event's duration using the information available in your trace.</p> 
			
		<h4>Example of interval symbols</h4>
		
			<p>An interval symbol is a symbol (a line) that represents the interval from a begin event to an end event.</p>
		
			<p>The <i>New interval symbol</i> form works similarly as the <i>New instantaneous symbol</i> form. 
			For example, the fourth rule draws the lines that represent the interval during which the property 'current_observation/color' remains unchanged. 
			These lines are positioned vertically according to the property 'current_observation/distance':</p>
		
			<img class="screenshot" src="images/screen9.png" /><br />
		
			<p>In the field <i>End condition</i> of this example, the variable $last represents the previous event in the trace.</p>
		
			<p>To facilitate the specification of the customization rules, we defined the additional function my:ifthenelse.</p>
		
				<pre class="code-sample">my:ifthenelse(&lt;condition&gt;, &lt;value if true&gt;, &lt;value if false&gt;)</pre>
				<p>If the first parameter is true, this function returns the value of the second parameter. If the first parameter is false, this function returns the value of the third parameter.</p>
				
				<p>Note that you can specify that a duration symbol should change its appearance depending on its ending condition.
				For example, an interval symbol could be displayed in blue while it is going on, and turn red or green depending on how it ends.</p>
			
				<p>You can now upload your own trace and start customizing its visualization (using "Upload a trace" in panel ➁).</p> 
				
		<h3>3. Customization with XSL Stylesheets</h3>
		
			<p>XSL stylesheets offer a more flexible way of customizing your visualization than the customization panel presented in Section 2.
			With this feature, you can freely define your visualization stylesheets on the server.</p> 
			<p>We, however, had to disable this feature on regular accounts because such freedom could open a security flaw 
			on the server if left uncontrolled. You can either use this feature with your Abstract Server installation, 
			or please contact <a href="mailto: olivier DOT georgeon AT liris DOT cnrs DOT fr">Olivier</a> 
			and <a href="mailto: ronot DOTT py AT gmail DOT com">Pierre-Yves</a> 
			for being granted this feature in your acount on the Liris server. 
			</p>
			<p>Once you are granted this feature, you see the panel shown in Figure 3. 
			This panel lets you modify, download, or upload the stylesheets.</p>
			<p>This section introduces the pipeline structure of Abstract Lite and 
			presents how to create customized XSL stylesheets within this structure.</p>
		
			<h4>The pipeline structure</h4>
				<p>Abstract Lite processes the events of the trace through a <i>transformation pipeline</i>.
				The transformation pipeline takes the events from the agent or from the trace file as inputs. 
				The events are then processed by a series of <i>transformation components</i> until generating a graphical symbol as an output. The graphical symbols are then printed on the display.</p>
				
				<p>The pipeline structure is defined in the file pipeline.xml. 
				To prevent loops, transformations components are organized into levels: 
				the events are first processed by the levels that appear first in the file.</p> 
				
				</p>Each transformation component has one or several <i>source</i> properties that define its input. 
				There are two special sources: <i>__input__</i> that is the initial source of raw events, 
				and <i>__config__</i> that defines events coming from the user interface. 
				The <i>output</i> property at the end defines where the events that are sent to the display come from.</p>
			<pre class="brush: xml">&lt;pipeline&gt;
	&lt;default-scale&gt;6.666666&lt;/default-scale&gt;
	&lt;default-center&gt;0&lt;/default-center&gt;
	&lt;graph-width&gt;240&lt;/graph-width&gt;

	&lt;levels&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;select-normalize&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;select-normalize.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;clock&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__input__&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;clock.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="PHP"&gt;
				&lt;name&gt;buffer-reconfigure&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;__config__&lt;/source&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;BufferReconfigureTransformation.inc.php&lt;/file&gt;
				&lt;classname&gt;BufferReconfigureTransformation&lt;/classname&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;tooltip&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;tooltip.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

		&lt;level&gt;
			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;config-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
					&lt;source&gt;buffer-reconfigure&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;configSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;

			&lt;transformation type="XSLT"&gt;
				&lt;name&gt;simple-SVG&lt;/name&gt;
				&lt;sources&gt;
					&lt;source&gt;select-normalize&lt;/source&gt;
				&lt;/sources&gt;
				&lt;file&gt;simpleSVG.xsl&lt;/file&gt;
			&lt;/transformation&gt;
		&lt;/level&gt;

	&lt;/levels&gt;

	&lt;output&gt;
		&lt;source&gt;simple-SVG&lt;/source&gt;
		&lt;source&gt;config-SVG&lt;/source&gt;
		&lt;source&gt;clock&lt;/source&gt;
		&lt;source&gt;tooltip&lt;/source&gt;
	&lt;/output&gt;
&lt;/pipeline&gt;
</pre>
			<h4>The default stylesheets</h4>
				
				<p>The base stylesheets aim to provide necessary informations to the player (clock.xsl), draw the ticks (simpleSVG.xsl), as well as to execute the symbole rules and draw the result (BufferReconfigureTransformation.php and configSVG.xsl). The stylesheet select-normalise.xsl filters and selects the incoming data (by default, it doesn't filter anything).</p>
				<p>You may modify simpleSVG.xsl if you want to define custom shapes. If you want to change what's displayed in the box below the player when you click on an obsel, you may want to modify tooltip.xsl. However, you *will* need to know basic XSLT and SVG.</p>
			
			<h4>The drawing instructions</h4>
				<p>The pipeline generate instructions that are passed to the player. The player then executes them. These are 4 instructions : add, delete, clock, tooltip.</p>
				<p>The instruction add allows you to add a given obsel (ie an SVG element) into the view.</p>
				<p>The instruction delete deletes the obsel having the given id from the view.</p>
				<p>The instruction clock tells the player at which point of the stream we currently are, resulting in the view to scroll to this date (the player does not automatically scroll to the latest obsel, because we may want the stream obsels in the future, without scrolling to them).</p>
				<p>The instruction tooltip set the association between the given obsel and the given tooltip content (in HTML).</p>
				<p>One more special element that looks like an instruction is the <i>save</i> element, that allows you to save informations (a value or a node-set) for use in a future obsel's processing. This can be especially useful when drawing symbols that take informations from multiple obsels to draw, thou its can be a little bit tricky.</p>
				
				<p>We will see these instructions in more details in the example</p>
				
			<h4>Example</h4>
				<p>We show here the simpleXML stylesheet in its initial state. Note the includes : obsel-state.xsl is necessary to the operation, while shapes.xsl provide shape drawing facilities in the form of the <i>draw-shape</i> template.</p>
				
				<pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:exsl="http://exslt.org/common" xmlns:math="http://exslt.org/math"
	xmlns:dyn="http://exslt.org/dynamic" extension-element-prefixes="exsl math dyn"
	version="1.1"&gt;
	&lt;xsl:param name="state-filename" /&gt;
	&lt;xsl:param name="name" /&gt;
	&lt;xsl:output method="xml" omit-xml-declaration="yes" indent="no" /&gt;
	&lt;xsl:strip-space elements="*" /&gt;

	&lt;xsl:include href="obsel-state.xsl" /&gt;
	&lt;xsl:include href="shapes.xsl" /&gt;

	&lt;!-- Match the obsels from the select-normalizer, that is, the ponctual 
		obsels. --&gt;
	&lt;xsl:template match="obsel" mode="named-saves"&gt;
		&lt;xsl:param name="state" /&gt;

		&lt;!-- We first define some variables which values we will use to draw the 
			shape. --&gt;
		&lt;xsl:variable name="obsel-type"&gt;
			&lt;xsl:choose&gt;
				&lt;xsl:when test="type"&gt;
					 &lt;xsl:value-of select="type" /&gt;
				&lt;/xsl:when&gt;
				&lt;xsl:otherwise&gt;
					&lt;xsl:text&gt;action&lt;/xsl:text&gt;
				&lt;/xsl:otherwise&gt;
			&lt;/xsl:choose&gt;
		&lt;/xsl:variable&gt;
		
		&lt;!-- Lateral position of the shape. --&gt;
		&lt;xsl:variable name="begin-position" select="0" /&gt;
		&lt;xsl:variable name="end-position"
			select="$begin-position + number(@end) - number(@begin)" /&gt;
		
		&lt;xsl:choose&gt;
			&lt;xsl:when test="$obsel-type = 'action'"&gt;
				&lt;add&gt;
					&lt;!-- We create the embedding group. --&gt;
					&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-num-iter"&gt;
							&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
							&lt;xsl:with-param name="end-position" select="$end-position" /&gt;
							&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
	&lt;/xsl:template&gt;
	
	&lt;xsl:template name="draw-num-iter"&gt;
		&lt;xsl:param name="begin-position" /&gt;
		&lt;xsl:param name="end-position" /&gt;
		&lt;xsl:param name="vertical-offset" /&gt;
		
		&lt;xsl:if test="number(@date) mod 10 = 0"&gt;
			&lt;xsl:call-template name="draw-shape"&gt;
				&lt;xsl:with-param name="vert-level" select="$vertical-offset" /&gt;
				&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
				&lt;xsl:with-param name="shape-type" select="'tick-sided-left'" /&gt;
				&lt;xsl:with-param name="text-value" select="clock" /&gt;
				&lt;xsl:with-param name="shape-color" select="'#000000'" /&gt;
				&lt;xsl:with-param name="height" select="'280'" /&gt;
			&lt;/xsl:call-template&gt;
		&lt;/xsl:if&gt;
	&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</pre>
				<p>Let's see how it works. The transformation's point of entry is the template that matches <i>obsel</I> elements. It will execute once for each obsel encountered, and call sub-templates to actually generate the various shapes. Only one sub-template is called at the moment, the <i>draw-num-iter</i> template. This template is the one that draws the ticks.</p>
				<p>If you look at what it does in more details, you will notice the SVG elements (including what's returned by the draw-shape template) are embedded into an &lt;add&gt; element. This is how the <i>add</i> instruction works: everything inside of an &lt;add&gt; element will be added to the view.</p>
				<p>Just inside that element, you can see a &lt;g&gt; element. Notice its attributes. They are necessary to allow the player to handle the symbol correctly and place it. The id element is necessary if you want to reference the shape later (for example to delete it). The date attribute will determine where the symbol is placed. The obsel-id correspond in our example to the id of the original obsel. The id will be used (only) to find the corresponding tooltip when the user click on this symbol (so you must be careful to create tooltip with corresponding ids; our policy here is to use the original obsel ids). The stroke attribute is not necessary, just standard SVG.</p>
				<p>If your symbol is not punctual, but represents a time interval, you should use the attributes <i>begin</i> and <i>end</i> instead of the attribute <i>date</i>. The player will then stretch the symbol to cover this interval (The symbol is supposed to be 1 pixel wide before the stretching).</p>
				<p>Inside of this &lt;g&gt;, is finally called the template that will generate the effective symbol SVG code. To do that, the <i>draw-num-iter</i> template calls <i>draw-shape</i>. What are the <i>draw-shape</i>'s parameters ?</p>
				<pre class="brush: xml">
					&lt;xsl:template name="draw-shape"&gt;
						&lt;xsl:param name="vert-level" /&gt;
						&lt;xsl:param name="begin-position" /&gt;
						&lt;xsl:param name="shape-type" /&gt;
						&lt;xsl:param name="image-url" select="''" /&gt;
						&lt;xsl:param name="text-value" select="''" /&gt;
						&lt;xsl:param name="shape-color" select="''" /&gt;
						&lt;xsl:param name="height" select="'10'" /&gt;
						&lt;xsl:param name="transform" select="''" /&gt;
						...
					&lt;/xsl:template&gt;</pre>
				<p> The parameters mean:<br/>
					<ul>
						<li><i>vert-level</i> defines the vertical offset in pixels at which the symbol is to be drawn (0 is the center, growing downward).</li>
						<li><i>begin-position</i> defines the horizontal offset in pixels (0 will position the symbol on the position defined by its date).</li>
						<li><i>shape-type</i> defines what shape should be drawn (square, circle, etc.).</li>
						<li><i>image-url</i> defines, in case the shape type is 'image', where is the image to draw.</li>
						<li><i>text-value</i> defines, if the shape type can have text, its text content.</li>
						<li><i>shape-color</i> defines the symbol's filling color.</li>
						<li><i>height</i> defines the height of the symbol (in case the shape type uses it).</li>
						<li><i>transform</i> is a string formatted to be used in a SVG transform attribute (for example 'rotate(45) skewX(33)'), that will be applied to the symbol.</li>
					</ul>
				</p>
				
				<p>Now suppose we want to do the same long symbol than we generated previously with the form. We had a field <i>current_observation/color</i> and we wanted to draw and aggregate symbol for successive obsels that have the same values for this field. What we want to do then, is for each obsel, to detect whether its <i>current_observation/color</i>'s value is the same as the previous symbol's, and extend the previous symbol until the date of the current obsel. If it is not equal, we should finish the previous symbol and create a new one.</p>
				
				<p>The first thing is to make our own drawing template and call it from the entry point. The call will look like:</p>
				<pre class="brush: xml">
					&lt;xsl:template match="obsel" mode="named-saves"&gt;
					&lt;xsl:param name="state" /&gt;

						&lt;!-- We first define some variables which values we will use to draw the 
							shape. --&gt;
						&lt;xsl:variable name="obsel-type"&gt;
							&lt;xsl:choose&gt;
								&lt;xsl:when test="type"&gt;
									 &lt;xsl:value-of select="type" /&gt;
								&lt;/xsl:when&gt;
								&lt;xsl:otherwise&gt;
									&lt;xsl:text&gt;action&lt;/xsl:text&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:variable&gt;
		
						&lt;!-- Lateral position of the shape. --&gt;
						&lt;xsl:variable name="begin-position" select="0" /&gt;
						&lt;xsl:variable name="end-position"
							select="$begin-position + number(@end) - number(@begin)" /&gt;
		
						&lt;xsl:choose&gt;
							&lt;xsl:when test="$obsel-type = 'action'"&gt;
							
								&lt;!-- This, here :. --&gt;
								&lt;xsl:call-template name="draw-example-symbol"&gt;
									&lt;xsl:with-param name="state" select="$state" /&gt;
								&lt;/xsl:call-template&gt;
								&lt;!-- Just up there. --&gt;
								
								&lt;add&gt;
									&lt;!-- We create the embedding group. --&gt;
									&lt;g id="{@id}-ns" obsel-id="{@id}" date="{@date}" stroke="#000000"&gt;
										&lt;xsl:call-template name="draw-num-iter"&gt;
											&lt;xsl:with-param name="begin-position" select="$begin-position" /&gt;
											&lt;xsl:with-param name="vertical-offset" select="-110" /&gt;
										&lt;/xsl:call-template&gt;
									&lt;/g&gt;
								&lt;/add&gt;
							&lt;/xsl:when&gt;
							&lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:template&gt;</pre>
				
				<p>And our template will be the following:</p>
				<pre class="brush: xml">
&lt;xsl:template name="draw-example-symbol"&gt;
		&lt;xsl:param name="state" /&gt;
		&lt;xsl:variable name="sym-state"
			select="$state/save[@name='example-sym']/symbol" /&gt;
		&lt;xsl:variable name="last-state" select="$state/save[@name='example-last']" /&gt;
		&lt;xsl:choose&gt;

			&lt;!-- In the case we have to create a new symbol: at the beginning or
				when colors mismatch between this element and the previous one. --&gt;
			&lt;xsl:when
				test="not($last-state/color) or $last-state/color != current_observation/color"&gt;
				&lt;!-- All we have to do is to add the symbol. --&gt;
				&lt;add&gt;
					&lt;g id="{@id}-s" obsel-id="{@id}" date="{@date}" begin="{@date}"
						end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level"
								select="- current_observation/distance div 5 + 75" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color"
								select="concat('#', current_observation/color)" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

				&lt;!-- We save the symbole caracteristics, we will probably have to draw 
					it again. --&gt;
				&lt;save name='example-sym'&gt;
					&lt;symbol id="{@id}-s" obsel-id="{@id}" begin="{@date}" end="{@date}"
						vert-level="{- current_observation/distance div 5 + 75}" 
						color="#{current_observation/color}" /&gt;
				&lt;/save&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;!-- We want to lengthen the symbole, so we first have to delete
					the old one, before we draw a longer one --&gt;
				&lt;delete obsel-id="{$sym-state/@id}" /&gt;

				&lt;!-- We draw the longer symbol, using the saved properties. --&gt;
				&lt;add&gt;
					&lt;g id="{$sym-state/@id}" obsel-id="{$sym-state/@obsel-id}" date="{$sym-state/@begin}"
						begin="{$sym-state/@begin}" end="{@date}" stroke="#000000"&gt;
						&lt;xsl:call-template name="draw-shape"&gt;
							&lt;xsl:with-param name="vert-level" select="$sym-state/@vert-level" /&gt;
							&lt;xsl:with-param name="begin-position" select="0" /&gt;
							&lt;xsl:with-param name="shape-type" select="'line'" /&gt;
							&lt;xsl:with-param name="shape-color" select="$sym-state/@color" /&gt;
						&lt;/xsl:call-template&gt;
					&lt;/g&gt;
				&lt;/add&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;!-- We save the current obsel color for the next iteration. --&gt;
		&lt;save name='example-last'&gt;
			&lt;color&gt;
				&lt;xsl:value-of select='current_observation/color' /&gt;
			&lt;/color&gt;
		&lt;/save&gt;
	&lt;/xsl:template&gt;
				</pre>
				
				<p>The nodes we save with the &lt;save&gt; instruction will be passed back to us by the state param next time the template is executed, allowing us to remember the last color value thanks to the <i>example-last</i> save, and the symbol characteristics thanks to the <i>example-sym</i> save.</p>

	<h3>4. Generate the trace in real time</h3>
	
		<p>This section describes how to implement a java agent that sends traces to Abstract Lite via streaming. 
		We appologize for the absence of tutorials for other programming languages than Java. 
		If you wish to use Abstract Lite with other kinds of agents, please contact us. 
	
		<p>Click <i>My cookie</i> in panel ➀ to obtain your private <i>cookie value</i> associated with your account. 
		Your agent will use this cookie value to stream its traces to your account in Abstract Lite.</p>
	
		<p>Download the Abstract Lite java package by following the <a href="install.html">installation procedure</a>.
		This package provides the java tracer class that your agent can use to sent its events to Abstract Lite. 
		This java tracer class is located in the subdir java-tracer/ . 
		A javadoc is available in <a href="java-tracer/tracer-doc/index.html">java-tracer/tracer-doc/index.html</a>.</p>
	
		<p> Your agent must first instantiate the tracer with two parameters. 
		The first parameter is the URL to which the events must be sent.
		The second parameter is the <i>cookie value</i>.  The instantiation instruction looks like this:</p>
		<pre class="code-sample">m_tracer = new XMLStreamTracer("http://vm.liris.cnrs.fr:34080/abstract/lite/php/stream/", "fjSmkmyvAKgByfDAfXuYGjAJLzrWrf");</pre>
		
		<p>Your agent can then generate its trace using the following methods: (a) generate an event with the <i>newEvent</i> method:</p>
		<pre class="code-sample">m_tracer.newEvent(timestamp);</pre>
		 
		<p>(b) populate the event with the <i>addEventElement</i> methods:</p>
		<pre class="code-sample">Object element = m_tracer.addEventElement("label", "value");</pre>
		 
		<p>(c) if necessary, add any number of element sub-levels with the <i>addSubelement</i> methods:<p>
		<pre class="code-sample">Object subElement = m_tracer.addSubelement(element, "label", "value");</pre>
		 
		<p>When the event is complete, the agent can finish it with the <i>finishEvent</i> method. Otherwise,  
		an event will be automatically finished when the agent starts the next event:</p>
		<pre class="code-sample">m_tracer.finishEvent();</pre>
		
		<p>We recommend to create only one event for each timestamp, to facilitate the transformations.</p>

	<h3>Contact</h3>
	
		<p>Abstract Lite is part of the <a href="http://liris.cnrs.fr/abstract">ABSTRACT project</a> and of the <a href="http://liris.cnrs.fr/ideal">IDEAL project</a>.
		It was developed by Pierre-Yves Ronot at the Liris lab in Lyon, France.</p>
		<p>For any question, comment, feedback, or proposition of collaboration, please contact <a href="mailto: ronot DOTT py AT gmail DOT com">Pierre-Yves Ronot </a> or <a href="mailto: olivier DOT georgeon AT liris DOT cnrs DOT fr">Olivier Georgeon</a>. 

	<pre class="code-sample"></pre>
</body>
</html>
